/*
Задано текст ASCII (текстовий рядок), який складається з 64 букв.
Написати функції шифрування та розшифрування заданого тексту.
Кожна при шифруванні буква тексту буде записана у елемент,
який складається з двох байтів та має структуру:
  -  у бітах 0-3 старша частина, тобто біти 4-7 ASCII - коду букви (4 біти) - СЧКБ,
  -  у бітах 4-10 позиція букви у рядку (7 біти) - ПБР,
  -  у бітах 12-15 молодша частина, тобто біти 0-3 ASCII - коду букви (4 біти) - МЧКБ,
  -  11 біт – біт парності отриманого запису (1 біт)  -БП.
  -    15 14 13 12  11  10 09 08 07 06 05 04 03 02 01 00
	   | МЧКБ    | |БП| |     ПБР          | |   СЧКБ  |
*/

/* Задано текст, який складається з 16 рядків до 4 символів у рядку. Доповнити пробілами рядки
до 16 символів. Шифрувати тексти таким чином, щоб кожний символ тексту записувався у два
байти. Два байти мають таку структуру:
у бітах 0-3 знаходиться номер рядка символу (4 біти),
у бітах 4-7 молодша частина ASCII - коду символу (4 біти),
8 біт – біт парності перших двох полів (1 біт)
у бітах 9-12 старша частина ASCII - коду символу (4 біти),
у бітах 13-14 позиція символу в рядку (2 біти),
15 біт - біт парності попередніх двох полів (1 біт). */

#include <iostream>

int main(char InS[64], unsigned short OutCoding[64])
{
	
		unsigned char c;
		unsigned short r, t, i, b;
		short j;
		for (i = 0; i < 64; i++)            //
		{
			r = 0;                        // 0000 0000 0000 0000
			c = InS[i];                     // s - 0x73 = 0111 0011
			t = c;
			r |= t >> 4;                  // 0000 0000 0000 0111
			r |= i << 4;                  // 0000 0000 0101 0111  if i=5 -> 0000 0000 0000 0101
			t = c;
			r |= t << 12;                 // 0011 0000 0101 0111  if i=5 0000 0000 0000 0101
			t = 1;
			b = 0;
			for (j = 0; j < 16; j++)         // обчислення біта парності
			{
				if (r & t) {
					if (b == 0) b = 1; else b = 0;
				}
				t <<= 1;
			}
			r |= b << 11;                    // 0011 0000 0101 0111 if i=5 0000 0000 0000 0101
			OutCoding[i] = r;
		}
	}
	struct TextCode {
		unsigned short schkb : 4;
		unsigned short posrow : 7;
		unsigned short bitp : 1;
		unsigned short mchkb : 4;

	};
	unsigned char pbit(unsigned char c)
	{
		unsigned char t = 1, b = 0;
		for (int j = 0; j < 8; j++)         // обчислення біта парності
		{
			if (c & t) {
				if (b == 0) b = 1; else b = 0;
			}
			t <<= 1;
		}
		return b;
	}
	void MyEncryptionS(char InS[64], TextCode OutCoding[64])
	{
		unsigned char c;
		unsigned short r, t, i;
		short j;
		for (i = 0; i < 64; i++)            //
		{
			c = InS[i];                     // s - 0x73 = 0111 0011
			OutCoding[i].schkb = c >> 4;
			OutCoding[i].mchkb = c & 0x0f;
			OutCoding[i].posrow = i;
			r = pbit(c);
			t = pbit(static_cast<unsigned char>(i));
			OutCoding[i].bitp = r ^ t;
		}
	}

	int MyDecryption(char OutS[64], unsigned short InCoding[64]) {

		unsigned char c;
		unsigned short r, t, i, b, p, w;
		short j;
		for (i = 0; i < 64; i++)            //
		{
			// Перевірка парності
			r = InCoding[i];
			t = r & 0b1111011111111111;      //  0xf7ff			1111 0111 1111 1111
			p = r & 0b0000100000000000;      //  0x0800			0000 1000 0000 0000
			w = 1;
			b = 0;
			for (j = 0; j < 16; j++)         // обчислення біта парності
			{
				if (t & w) {
					if (b == 0) b = 1; else b = 0;
				}
				w <<= 1;
			}
			p >>= 11;
			if (p != b)  return -i;
			t = r & 0b1111000000000000;  // 0xf000
			t >>= 12;
			w = r & 0b0000000000001111;  // 0x000f
			w <<= 4;
			t |= w;
			p = r & 0b0000011111110000;  // 0x07f
			p >>= 4;
			OutS[p] = (unsigned char)t;
		}
		return 1;
	
}